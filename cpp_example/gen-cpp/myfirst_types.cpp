/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "myfirst_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




MyError::~MyError() noexcept {
}


void MyError::__set_error_code(const int32_t val) {
  this->error_code = val;
}

void MyError::__set_error_description(const std::string& val) {
  this->error_description = val;
}
std::ostream& operator<<(std::ostream& out, const MyError& obj)
{
  obj.printTo(out);
  return out;
}


void swap(MyError &a, MyError &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_description, b.error_description);
  swap(a.__isset, b.__isset);
}

MyError::MyError(const MyError& other0) : TException() {
  error_code = other0.error_code;
  error_description = other0.error_description;
  __isset = other0.__isset;
}
MyError& MyError::operator=(const MyError& other1) {
  error_code = other1.error_code;
  error_description = other1.error_description;
  __isset = other1.__isset;
  return *this;
}
void MyError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MyError(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_description=" << to_string(error_description);
  out << ")";
}

const char* MyError::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: MyError";
  }
}


